-----------------------------
monomer.py
-----------------------------
import json
from typing import Tuple

from .bonds import Bond
from .topology import Topology

from enum import Enum
class SubTopologyType(Enum):
    LHS = "LHS"
    LINK = "LINK"
    RHS = "RHS"
    
class Monomer:
    def __init__(self, topology: Topology, bond_a: Bond, bond_b: Bond):
        self.topology = topology
        self.bond_a = bond_a
        self.bond_b = bond_b
        self.LHS, self.link, self.RHS = self.build_monomer()

    def build_monomer(self) -> Tuple[Topology, Topology, Topology]:
        # build 3 sub-topologies before (LHS) and after (RHS) and between (link) the 2 bonds
        # create 3 topologies LHS (before bond_b), RHS (after bond_a) and link (between bonds a and b)
        # distribute lost charges in each topology
        # return a tuple of 3 topologies
        A,B = self.topology.split(self.bond_a)
        bond_b_in_B = B.get_bond_by_name(self.bond_b.atom_a.atom_name, self.bond_b.atom_b.atom_name)
        
        if not bond_b_in_B:
            B,A = A,B
            bond_b_in_B = B.get_bond_by_name(self.bond_b.atom_a.atom_name, self.bond_b.atom_b.atom_name)
        B,C = B.split(self.bond_b)
        if len(C.pseudoatoms) >1:
            B,C = C,B
        
        return A, B, C


    def to_dict(self):
        return{
            "topology": self.topology.to_dict(),
            "bond_a": self.bond_a.to_dict(),
            "bond_b": self.bond_b.to_dict(),
        }

    @classmethod
    def from_dict(cls, data):
        topology = Topology.from_dict(data["topology"])
        bond_a = Bond.from_dict(data["bond_a"],topology.atoms)
        bond_b = Bond.from_dict(data["bond_b"],topology.atoms)
        return cls(topology, bond_a, bond_b)

    def save(self, file_path):

        with open(file_path, "w") as f:
            json.dump(self.to_dict(), f)

    @classmethod
    def load(cls, file_path):
        with open(file_path, "r") as f:
            data = json.load(f)

        return cls.from_dict(data)
-----------------------------
polymer.py
-----------------------------
from __future__ import annotations

import json
import random
import re
from typing import Dict, List, Optional, Tuple, Union

from .monomer import Monomer
from .topology import Topology


class Polymer:
    def __init__(
        self,
        monomers: List[Monomer],
        distribution: List[float],
        num_monomers: int,
        seed: Optional[int] = None,
        start_monomer: Optional[Monomer] = None,
        end_monomer: Optional[Monomer] = None,
    ):
        self.monomers = monomers
        self.distribution = distribution
        self.seed = seed
        self.num_monomers = num_monomers
        self.start_monomer = start_monomer
        self.end_monomer = end_monomer

    def get_topology(self) -> Topology:
        polymer_topology = Topology()
        if self.seed:
            random.seed(self.seed)
        else:
            random.seed = random.randint  # unseeded randomization
        # TODO implement build polymer
        monomers_remaining = self.num_monomers

        if self.start_monomer:
            polymer_topology.extend_with_topology(self.start_monomer.LHS)
            monomers_remaining -= 1

        monomers_remaining -= 1

        for _ in range(monomers_remaining):
            chosen_monomer = random.choices(self.monomers, weights=self.distribution)[0]
            # polymer_topology.extend_with_topology(chosen_monomer.link)

        if self.end_monomer:
            polymer_topology.extend_with_topology(self.end_monomer.RHS)
        else:
            chosen_monomer = random.choices(self.monomers, weights=self.distribution)[0]
            polymer_topology.extend_with_topology(chosen_monomer.RHS)

        return polymer_topology

    def save_to_file(self, filename: str) -> None:
        with open(filename, "w") as f:
            json.dump(self.to_dict(), f)

    def load_from_file(self, filename: str) -> None:
        with open(filename, "r") as f:
            data = json.load(f)
        self.from_dict(data)

    def to_dict(
        self,
    ) -> Dict[
        str,
        Union[
            List[Dict[str, Union[float, int]]],
            int,
            Optional[Dict[str, Union[float, int]]],
        ],
    ]:
        return {
            "monomers": [monomer.to_dict() for monomer in self.monomers],
            "distribution": self.distribution,
            "num_monomers": self.num_monomers,
            "seed": self.seed,
            "start_monomer": self.start_monomer.to_dict()
            if self.start_monomer
            else None,
            "end_monomer": self.end_monomer.to_dict() if self.end_monomer else None,
        }

    @classmethod
    def from_dict(
        cls,
        data: Dict[
            str,
            Union[
                List[Dict[str, Union[float, int]]],
                int,
                Optional[Dict[str, Union[float, int]]],
            ],
        ],
    ) -> Polymer:
        monomers = [
            Monomer.from_dict(monomer_data) for monomer_data in data["monomers"]
        ]
        distribution = data["distribution"]
        num_monomers = data["num_monomers"]
        seed = data["seed"]
        start_monomer_data = data.get("start_monomer")
        start_monomer = (
            Monomer.from_dict(start_monomer_data) if start_monomer_data else None
        )
        end_monomer_data = data.get("end_monomer")
        end_monomer = Monomer.from_dict(end_monomer_data) if end_monomer_data else None
        return cls(
            monomers, distribution, seed, num_monomers, start_monomer, end_monomer
        )
-----------------------------
