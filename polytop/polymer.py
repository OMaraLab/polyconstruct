from __future__ import annotations

import json
import random
import re
from typing import Dict, List, Optional, Tuple, Union
from polytop.bonds import Bond
from polytop.junction import Junction, Junctions
from .topology import Topology
import datetime

class Polymer:

    def __init__(self, monomer):
        self.topology = monomer.topology.copy()
        self.topology.preamble = [f"Generated by PolyTop\n\nAuthor: Richard A. Morris (u6612992@anu.edu.au)\n\nDate: {datetime.date.today()}"]
        self.junctions = Junctions()
        for junction in monomer.junctions:
            atom_a_id = junction.location.atom_a.atom_id
            atom_b_id = junction.location.atom_b.atom_id
            self.junctions.add(Junction(junction.name, self.topology.get_bond(atom_a_id, atom_b_id)))

    def has_junction(self, name):
        return any(junction.name == name for junction in self.junctions)
    
    def DFS(self, atom, visited, exclude=None):
        visited.add(atom)
        for neighbor in atom.bond_neighbours():
            if neighbor is not exclude and neighbor not in visited:
                self.DFS(neighbor, visited, exclude)

    def extend(self, monomer, from_junction_name, to_junction_name):
        # take a copy of the topology of the monomer 
        new_monomer = monomer.copy()
        
        # renumber all atoms above the max atom id of the polymer
        new_monomer.topology.renumber_atoms(max(atom.atom_id for atom in self.topology.atoms)+1)

        # choose the first polymerization junction of the monomer named to_junction_name to extend this monomer from
        to_junction = next((junction for junction in new_monomer.junctions if junction.name == to_junction_name), None)
        if to_junction is None:
            raise ValueError(f"No junction named {to_junction_name} found in the monomer")
        else:
            new_monomer.junctions.remove(to_junction)

        # do a depth first search of the monomer to find all atoms connected to the to_junction including the first atom in the junction
        discard_from_monomer=set()
        self.DFS(to_junction.location.atom_a, discard_from_monomer, exclude=to_junction.location.atom_b)

        # choose a random polymerization junction of the polymer with from_junction_name to extend this monomer into
        from_junction = random.choice([junction for junction in self.junctions if junction.name == from_junction_name])
        if from_junction is None:
            raise ValueError(f"No junction named {from_junction_name} found in the polymer")
        else:
            self.junctions.remove(from_junction)
        
        # do a depth first search of the polymer to find all atoms connected to the from_junction including the second atom in the junction
        discard_from_polymer=set()
        self.DFS(from_junction.location.atom_b, discard_from_polymer, exclude=from_junction.location.atom_a)
        
        # Add the monomer's topology to the polymer
        self.topology.add(new_monomer.topology)
        for junction in new_monomer.junctions:
            atom_a_id = junction.location.atom_a.atom_id
            atom_b_id = junction.location.atom_b.atom_id
            self.junctions.add(Junction(junction.name, self.topology.get_bond(atom_a_id, atom_b_id)))
        
        # bond the two outer atoms at the junctions
        self.topology.bonds.append(Bond(from_junction.location.atom_a, to_junction.location.atom_b, 1, 1, 1))

        # TODO: copy the average of the 2 lost bond angles over the junction
        
        # remove the redundant atoms and bonds
        for atom in discard_from_monomer:
            self.topology.remove_atom(atom)
            
        for atom in discard_from_polymer:
            self.topology.remove_atom(atom)
        
    def save_to_file(self, filename: str) -> None:
        with open(filename, "w") as f:
            json.dump(self.to_dict(), f)

    @classmethod
    def load_from_file(cls, filename: str) -> None:
        with open(filename, "r") as f:
            data = json.load(f)
        return cls.from_dict(data)

    def to_dict(
        self,
    ) -> Dict[
        str,
        Union[
            List[Dict[str, Union[float, int]]],
            int,
            Optional[Dict[str, Union[float, int]]],
        ],
    ]:
        return {
            "topology": self.topology.to_dict(),
            "junctions": self.junctions.to_dict()
        }

    @classmethod
    def from_dict(
        cls,
        data: Dict[
            str,
            Union[
                List[Dict[str, Union[float, int]]],
                int,
                Optional[Dict[str, Union[float, int]]],
            ],
        ],
    ) -> Polymer:
        new_topology = Topology.from_dict(data["topology"])
        new_junctions = Junctions.from_dict(data["junctions"], new_topology.atoms)
        return cls(
            topology=new_topology,
            junctions=new_junctions,
        )
        
    def __repr__(self) -> str:
        return f"Polymer(({len(self.topology.atoms)} atoms), junctions:{self.junctions.count()})"